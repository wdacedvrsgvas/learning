// 基于比较的排序算法:插入排序,交换排序,选择排序,归并排序
// 不基于比较的排序算法:基数排序

// 在排序过程中，若整个表都是放在内存中处理，排序时不涉及数据的内、外存交换，则称之为内排序；

// 理想:
// 决策树是一棵有n!个叶结点的二叉树
//  叶结点个数=n!
//  总结点个数=n0+n2=2n!-1(n2 = n0-1)
//  h=log2(总结点个数+1)=log2(2n!) ≈ nlog2n
//  平均关键字比较次数=h-1
//  移动次数也是同样的数量级，即这样的算法平均时间复杂度为O(nlog2n)。

// n个记录采用基于比较的排序方法：
// 最好的平均时间复杂度为O(nlog2n) 。　
// 最好情况是排序序列正序，此时的时间复杂度为O(n)。

// 内排序算法的稳定性
// 如果待排序的表中，存在有多个关键字相同的记录，经过排序后这些具有相同关键字的记录之间的相对次序保持不变，则称这种排序方法是稳定的。

// 若待排序的表中元素已按关键字排好序，称此表中元素为正序；
// 反之，若待排序的表中元素的关键字顺序正好和排好序的顺序相反，称此表中元素为反序。

// 数据元素类型定义:
typedef int KeyType; // 定义关键字类型
typedef struct       // 记录类型
{
    KeyType key;   // 关键字项
    InfoType data; // 其他数据项,类型为InfoType
} RecType;         // 排序的记录类型定义

// 1.插入排序
//  主要的插入排序方法：
//  （1）直接插入排序
//  （2）折半插入排序
//  （3）希尔排序
// 基本思路:有序区<-一个一个地插入-无序区
// 不一定是全局有序（整体有序）  全局有序区的元素在后面排序中不再发生位置的改变

// 1.1直接插入排序
// 初始时，有序区只有一个元素R[0]
// i＝1~n-1，共经过n-1趟排序
void InsertSort(RecType R[]，int n)
{
    int i， j;
    RecType tmp;
    for (i = 1; i < n; i++)
    {
        if (R[i].key<R[i-1].key])	//反序时
        {
            tmp = R[i];
            j = i - 1;
            do // 找R[i]的插入位置
            {
                R[j + 1] = R[j]; // 将关键字大于R[i].key的记录后移
                j--;
            } while (j >= 0 && R[j].key > tmp.key)
                R[j + 1] = tmp; // 在j+1处插入R[i]
        }
    }
}
// 算法分析    最好：O(n)  最坏：O(n2)  最坏：O(n2)

// 1.2折半插入排序
